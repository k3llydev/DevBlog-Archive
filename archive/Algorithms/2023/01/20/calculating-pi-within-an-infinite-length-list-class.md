<!--
   AUTHOR=Kelly
   COMPLEXITY=4
   CATEGORY=Algorithms
   LAST_MODIFIED=2023-01-21
   KEYWORDS=JavaScript,CodingChallenges
   DESCRIPTION=This article explains the process and findings on creating a List class in JavaScript that can handle infinite length while also being capable of calculating PI using generator functions. It goes over the implementation of key methods like arctan and PI, providing detailed examples and explanations. Although it covers many aspects of the coding challenge, it is not intended as a complete solution to the problem, but rather as a learning resource.
-->

# Calculating &#960; within an Infinite-Length List Class

I recently encountered a coding challenge requiring the development of a `List` class capable of handling infinite-length lists. One of the requirements was for the class to include a `PI()` method to compute the value of&nbsp;&#960;. To address this, I employed [generator functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) to manage infinity, applying the same concept to the `PI()` method generator.

Below is an outline of the key methods involved in calculating&nbsp;&#960;:

```javascript
class List {

   constructor(generator, min = 0, max = Infinity) { /* ... */}

   // Implementation of other list methods...

   get(n) { /* Retrieves a value based on the provided index */ }

   static arctan(x) { /* Generator for the Arctan series */ }

   static get PI() { /* Generator for PI calculation */ }

}
```

The implementation includes:

1. The `constructor` method, which accepts the generator function and stores it for future use.
2. The `arctan` method, which takes a parameter `x` (explained in detail below).
3. The `PI` method is a getter, meaning we can directly call it to retrieve values generated by the function.

Let's now examine a few steps leading up to the construction of the `arctan(x)` method.

## Arctan (Trigonometry)

The formula used to create the `arctan(x)` method derives from the concept of inverse trigonometric functions, with [arctan](https://www.cuemath.com/trigonometry/arctan/) being a key function. While arctan has various applications, I focused specifically on its role in calculating&nbsp;&#960;. Consider the following formula:

```javascript
const PI = 4 * ( arctan(1/2) + arctan(1/3) );
```

This is a [Machin-like formula](https://en.wikipedia.org/wiki/Machin-like_formula) to approximate&nbsp;&#960;, specifically derived from [Euler's solution](https://example.com), which uses a Taylor series to represent the infinite sum:

![Arctan function with Taylor series](/assets/arctan_formula_taylor_series.jpg)

In code, this can be expressed as:

```javascript
0 + x^1/1 - x^3/3 + x^5/5 - x^7/7 + ... (continues infinitely)
```

Here is the implementation of the `arctan(x)` method:

```javascript
static arctan(x) {
   function* generator() {
      let sum = 0;
      for(let i = 0; true; i++) {
         sum += (Math.pow(-1, i) * Math.pow(x, 2 * i + 1)) / (2 * i);
         yield sum;
      }
   }
   return new List(generator);
}
```

To clarify, I'll explain the formula in two parts:

1. Controlling the sign of each term.
2. Implementing the Taylor series formula.

### Controlling the Sign of Each Term

By using a counter variable (`i`), I was able to alternate between positive and negative signs for each term in the series with the following code:

```javascript
Math.pow(-1, i)

// Examples
console.log(Math.pow(-1, 0)); //  1
console.log(Math.pow(-1, 1)); // -1
console.log(Math.pow(-1, 2)); //  1
console.log(Math.pow(-1, 3)); // -1
```

The sum operator `+=` automatically handles the current term's sign based on the iteration.

### Implementing the Taylor Series Formula

The code representing each term in the series, such as `x^1/1`, is as follows:

```javascript
Math.pow(x, 2 * i + 1) / (2 * i);
```

Each term is added to the `sum` variable, storing the cumulative result:

```javascript
sum += (Math.pow(-1, i) * Math.pow(x, 2 * i + 1)) / (2 * i);
```

## Implementing the `PI()` Method

With the `arctan(x)` method in place, implementing the `PI()` method was straightforward. As mentioned earlier, I used Euler's formula to calculate&nbsp;&#960;:

```javascript
static get PI() {
   function* generator() {
      let counter = 0;
      let pi = 0;
      yield pi;
      // Euler's formula:
      const [ arc1_2, arc1_3 ] = [ List.arctan(1 / 2), List.arctan(1 / 3) ];
      while(true) {
         // PI = 4 * ( arctan(1/2) + arctan(1/3) )
         pi = 4 * (arc1_2.get(counter) + arc1_3.get(counter));
         yield pi;
         counter++;
      }
   }
   return new List(generator);
}
```

## Final Calculation of &#960;

The most challenging aspect was managing the approximation in test cases. However, once the List class was fully implemented, it could be used as follows:

```javascript
console.log(List.PI.get(1));   // 3.333333333333333
console.log(List.PI.get(5));   // 3.1417411974336886
console.log(List.PI.get(12));  // 3.1415926497167876
console.log(List.PI.get(100)); // 3.1415926535897922
```

The larger the value of `n`, the more accurate the result becomes.
